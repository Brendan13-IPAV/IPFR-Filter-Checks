<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IP Strategy Relevance Review</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 16px;
            padding: 24px;
            margin-bottom: 24px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }

        .header h1 {
            font-size: 2.2rem;
            font-weight: 700;
            background: linear-gradient(135deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 8px;
        }

        .header p {
            color: #666;
            font-size: 1.1rem;
            margin-bottom: 16px;
        }

        .header-controls {
            display: grid;
            grid-template-columns: 1fr 1fr 250px;
            gap: 24px;
            align-items: end;
            margin-top: 20px;
        }

        .user-greeting {
            display: flex;
            align-items: center;
            font-weight: 600;
            color: #374151;
            font-size: 16px;
        }

        .primary-filters {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 16px;
        }

        .filter-group {
            display: flex;
            flex-direction: column;
        }

        .filter-label {
            font-weight: 600;
            margin-bottom: 8px;
            color: #374151;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        select {
            padding: 12px 16px;
            border: 2px solid #e1e5e9;
            border-radius: 8px;
            font-size: 14px;
            transition: all 0.3s ease;
            background: white;
        }

        select:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .top-controls {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 8px;
        }

        .results-count {
            font-weight: 600;
            color: #374151;
            font-size: 14px;
        }

        .control-buttons {
            display: flex;
            gap: 8px;
        }

        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 13px;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }

        .btn-secondary {
            background: #f8f9fa;
            color: #495057;
            border: 2px solid #e9ecef;
        }

        .btn-secondary:hover {
            background: #e9ecef;
            transform: translateY(-1px);
        }

        .btn-primary {
            background: #667eea;
            color: white;
            border: 1px solid #667eea;
        }

        .btn-primary:hover {
            background: #5a6fd8;
            transform: translateY(-1px);
        }

        .btn-success {
            background: #10b981;
            color: white;
            border: 1px solid #10b981;
        }

        .btn-success:hover {
            background: #059669;
            transform: translateY(-1px);
        }

        .btn-success:disabled {
            background: #d1d5db;
            border-color: #d1d5db;
            cursor: not-allowed;
            transform: none;
        }

        .main-layout {
            display: grid;
            grid-template-columns: 350px 1fr;
            gap: 24px;
            align-items: start;
        }

        .sidebar {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 16px;
            padding: 24px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            position: sticky;
            top: 20px;
            max-height: calc(100vh - 40px);
            overflow-y: auto;
        }

        .content-area {
            min-width: 0;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 16px;
            padding: 24px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }

        .active-filter-pill {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 12px 20px;
            border-radius: 25px;
            font-size: 16px;
            font-weight: 600;
            display: inline-flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 20px;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }

        .active-filter-pill button {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            cursor: pointer;
            font-size: 18px;
            padding: 4px 8px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            width: 24px;
            height: 24px;
        }

        .active-filter-pill button:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.1);
        }

        .accordion-header {
            background: #f8f9fa;
            padding: 12px 16px;
            border-radius: 8px;
            cursor: pointer;
            margin-bottom: 8px;
            font-weight: 600;
            transition: all 0.3s ease;
            border: 2px solid transparent;
        }

        .accordion-header:hover {
            background: #e9ecef;
            border-color: #667eea;
        }

        .accordion-content {
            background: white;
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 16px;
            border: 1px solid #e1e5e9;
        }

        .radio-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .radio-button {
            padding: 12px 16px;
            border: 2px solid #e1e5e9;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            background: white;
            font-size: 14px;
            font-weight: 500;
            user-select: none;
        }

        .radio-button:hover {
            background: #f8f9fa;
            border-color: #667eea;
            transform: translateY(-1px);
        }

        .radio-button.radio-selected {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border-color: #667eea;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
        }

        /* RELEVANCE BAND LAYOUT */
        .relevance-band {
            margin-bottom: 32px;
        }

        .band-header {
            background: #f8f9fa;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            padding: 12px 20px;
            margin-bottom: 16px;
            font-weight: 700;
            font-size: 16px;
            color: #374151;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .band-title {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .band-badge {
            color: white;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: 600;
        }

        .band-badge.highly-likely {
            background: #10b981;
        }

        .band-badge.likely {
            background: #3b82f6;
        }

        .band-badge.possible {
            background: #f59e0b;
        }

        .band-badge.unlikely {
            background: #ef4444;
        }

        .band-badge.not-applicable {
            background: #6b7280;
        }

        .band-count {
            font-size: 14px;
            color: #6b7280;
            font-weight: 500;
        }

        .strategies-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 16px;
        }

        .strategy-card {
            background: white;
            border: 2px solid #e1e5e9;
            border-radius: 12px;
            padding: 16px;
            transition: all 0.3s ease;
            position: relative;
            min-height: 280px;
            display: flex;
            flex-direction: column;
        }

        .strategy-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.1);
            border-color: #667eea;
        }

        .strategy-card.manually-moved {
            border: 3px solid #10b981;
            background: #f0fdf4;
        }

        .strategy-card.auto-moved {
            border: 2px solid #d1d5db;
            background: #f9fafb;
        }

        .strategy-card.ghost {
            background: transparent;
            border: 2px dashed #d1d5db;
            min-height: 100px;
            opacity: 0.5;
        }

        .strategy-card.ghost .card-header {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: #9ca3af;
            font-size: 14px;
        }

        .strategy-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: linear-gradient(135deg, #667eea, #764ba2);
        }

        .strategy-card.ghost::before {
            display: none;
        }

        .move-badge {
            position: absolute;
            top: 12px;
            right: 12px;
            background: #10b981;
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 700;
            z-index: 10;
        }

        .move-badge.auto {
            background: #6b7280;
        }

        .card-header {
            margin-bottom: 12px;
            flex: 1;
        }

        .card-overtitle {
            font-size: 11px;
            color: #667eea;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 4px;
        }

        .card-title {
            font-size: 1rem;
            font-weight: 700;
            color: #1f2937;
            margin-bottom: 8px;
            line-height: 1.3;
        }

        .card-description {
            color: #6b7280;
            line-height: 1.4;
            font-size: 13px;
        }

        .card-score {
            font-size: 12px;
            color: #6b7280;
            margin-top: 8px;
            font-weight: 600;
        }

        .card-controls {
            border-top: 1px solid #e5e7eb;
            padding-top: 12px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .movement-buttons {
            display: flex;
            gap: 4px;
        }

        .move-btn {
            background: #667eea;
            color: white;
            border: none;
            border-radius: 4px;
            width: 32px;
            height: 32px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            transition: all 0.2s ease;
        }

        .move-btn:hover:not(:disabled) {
            background: #5a6fd8;
            transform: scale(1.1);
        }

        .move-btn:disabled {
            background: #d1d5db;
            cursor: not-allowed;
            opacity: 0.5;
        }

        .flag-button {
            background: #f59e0b;
            color: white;
            border: none;
            border-radius: 6px;
            padding: 6px 12px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
            transition: all 0.2s ease;
        }

        .flag-button:hover {
            background: #d97706;
        }

        .flag-button.flagged {
            background: #10b981;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #666;
        }

        .no-results {
            text-align: center;
            padding: 60px 40px;
            color: #666;
        }

        .warning-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .warning-content {
            background: white;
            border-radius: 12px;
            padding: 24px;
            max-width: 500px;
            margin: 20px;
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.3);
        }

        .warning-title {
            font-size: 1.2rem;
            font-weight: 700;
            color: #dc2626;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .warning-message {
            color: #374151;
            line-height: 1.5;
            margin-bottom: 20px;
        }

        .warning-buttons {
            display: flex;
            gap: 12px;
            justify-content: flex-end;
        }

        .btn-warning {
            background: #dc2626;
            color: white;
            border: 1px solid #dc2626;
        }

        .btn-warning:hover {
            background: #b91c1c;
        }

        .password-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
        }

        .password-content {
            background: white;
            border-radius: 16px;
            padding: 40px;
            max-width: 400px;
            text-align: center;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        }

        .password-content h2 {
            margin-bottom: 16px;
            color: #374151;
        }

        .password-content p {
            margin-bottom: 20px;
            color: #6b7280;
        }

        .password-content input {
            width: 100%;
            padding: 12px 16px;
            border: 2px solid #e1e5e9;
            border-radius: 8px;
            font-size: 16px;
            margin-bottom: 16px;
        }

        .password-content input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .password-error {
            color: #dc2626;
            margin-top: 12px;
            font-weight: 600;
        }

        .password-modal.hidden {
            display: none;
        }

        .flag-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
        }

        .flag-modal-content {
            background: white;
            border-radius: 12px;
            padding: 24px;
            max-width: 500px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
        }

        .flag-modal-title {
            font-size: 1.2rem;
            font-weight: 700;
            margin-bottom: 8px;
            color: #374151;
        }

        .flag-modal-subtitle {
            font-size: 0.9rem;
            color: #6b7280;
            margin-bottom: 20px;
        }

        .flag-option {
            padding: 12px 16px;
            border: 2px solid #e1e5e9;
            border-radius: 8px;
            cursor: pointer;
            margin-bottom: 8px;
            transition: all 0.2s ease;
        }

        .flag-option:hover {
            background: #f8f9fa;
            border-color: #667eea;
        }

        .flag-option.selected {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border-color: #667eea;
        }

        .flag-textarea {
            width: 100%;
            padding: 12px;
            border: 2px solid #e1e5e9;
            border-radius: 8px;
            resize: vertical;
            min-height: 100px;
            font-family: inherit;
            font-size: 14px;
            margin-top: 16px;
        }

        .flag-textarea:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .flag-modal-buttons {
            display: flex;
            gap: 12px;
            margin-top: 20px;
        }

        .flag-modal-buttons button {
            flex: 1;
        }
    </style>
</head>
    
<body>
    <!-- Password Protection Modal with Name Input -->
    <div id="passwordModal" class="password-modal">
        <div class="password-content">
            <h2>üîí Access Required</h2>
            <p>Please enter your details to access the review tool:</p>
            <input type="text" id="loginNameInput" placeholder="Your name" />
            <input type="password" id="passwordInput" placeholder="Password" />
            <button class="btn btn-primary" onclick="checkPassword()">Submit</button>
            <div id="passwordError" class="password-error"></div>
        </div>
    </div>

    <div class="container">
        <div class="header">
            <h1>IP Strategy Relevance Review</h1>
            <p>Review strategy relevance bands and flag issues</p>
            <div id="versionDisplay"></div>
            
            <div class="header-controls">
                <div class="user-greeting">
                    üë§ <span id="userGreeting">Loading...</span>
                </div>
                
                <div class="primary-filters">
                    <div class="filter-group">
                        <label class="filter-label">Situation Type</label>
                        <select id="situationFilter">
                            <option value="">All Situations</option>
                            <option value="Enforcement">I believe my IP has been infringed</option>
                            <option value="Accused">I've been accused of infringement</option>
                            <option value="Disagree">I want help on IP processes</option>
                            <option value="Proactive">I want to prevent future IP headaches</option>
                        </select>
                    </div>
                    <div class="filter-group">
                        <label class="filter-label">IP Rights Type</label>
                        <select id="ipRightsFilter">
                            <option value="">All IP Rights</option>
                            <option value="Patent">Patents</option>
                            <option value="Trade mark">Trade marks</option>
                            <option value="Design">Design rights</option>
                            <option value="PBR">Plant breeder's rights</option>
                            <option value="Copyright">Copyright</option>
                            <option value="Any dispute">Any IP right</option>
                        </select>
                    </div>
                </div>

                <div class="top-controls">
                    <div class="results-count" id="resultsCount">Loading...</div>
                    <div class="control-buttons">
                        <button class="btn btn-secondary" id="clearFilters">üóëÔ∏è Clear</button>
                        <button class="btn btn-success" id="submitChangesBtn" disabled>
                            Submit Changes (<span id="pendingCount">0</span>)
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <div class="main-layout">
            <div class="sidebar">
                <div id="accordionContainer"></div>
            </div>

            <div class="content-area">
                <div id="activeFilterPill"></div>
                <div id="strategiesContainer">
                    <div class="loading">Loading strategy data...</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ========================================
        // CONFIGURATION
        // ========================================
        const BAND_CONFIG = {
            highlyLikely: { percentage: 0.20, minCount: 3, label: 'Highly Likely', cssClass: 'highly-likely' },
            likely: { percentage: 0.20, minCount: 0, label: 'Likely', cssClass: 'likely' },
            possible: { percentage: 0.20, minCount: 0, label: 'Possible', cssClass: 'possible' },
            unlikely: { percentage: 0.20, minCount: 0, label: 'Unlikely', cssClass: 'unlikely' },
            notApplicable: { label: 'Not Applicable', cssClass: 'not-applicable' }
        };

        const BAND_ORDER = ['highlyLikely', 'likely', 'possible', 'unlikely', 'notApplicable'];

        // Application state
        let allStrategies = [];
        let filteredStrategies = [];
        let activeFilters = [];
        let accordionState = {};
        let filterOptions = {};
        let accordionPresets = {};
        let currentUserName = '';
        let pendingMoves = {}; // { strategyId: { fromBand, toBand, isManual, reason } }

        const dataVersions = {
            strategiesContent: null,
            strategiesMetadata: null,
            filterOptions: null,
            accordionPresets: null,
            loadTimestamp: null
        };

        // DOM elements
        const userGreeting = document.getElementById('userGreeting');
        const situationFilter = document.getElementById('situationFilter');
        const ipRightsFilter = document.getElementById('ipRightsFilter');
        const clearFilters = document.getElementById('clearFilters');
        const resultsCount = document.getElementById('resultsCount');
        const accordionContainer = document.getElementById('accordionContainer');
        const activeFilterPill = document.getElementById('activeFilterPill');
        const strategiesContainer = document.getElementById('strategiesContainer');
        const submitChangesBtn = document.getElementById('submitChangesBtn');
        const pendingCount = document.getElementById('pendingCount');

        // ========================================
        // TELEMETRY CONFIGURATION
        // ========================================
        const TELEMETRY_CONFIG = {
            sheetURL: 'https://script.google.com/macros/s/AKfycbyK2DqvUFqwmbMUcs2fYhhnz0F3Zu4GC8Mfm_hxRGO9DYllfJase10FeuJvHGecMvAp/exec',
            accessPassword: 'ipnavigator2024',
            sessionId: generateSessionId()
        };

        function generateSessionId() {
            return 'session_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        }

        // Display version info in header
        function displayVersionInfo() {
            const versionDisplay = document.getElementById('versionDisplay');
            if (versionDisplay && dataVersions.strategiesContent) {
                versionDisplay.innerHTML = `
                    <div style="font-size: 11px; color: #6b7280; margin-top: 8px;">
                        <strong>Data Versions:</strong> 
                        Strategies: ${dataVersions.strategiesContent} | 
                        Metadata: ${dataVersions.strategiesMetadata} | 
                        Filters: ${dataVersions.filterOptions} | 
                        Presets: ${dataVersions.accordionPresets}
                    </div>
                `;
            }
        }

        // ========================================
        // PASSWORD PROTECTION
        // ========================================
        function checkPassword() {
            const nameInput = document.getElementById('loginNameInput');
            const passwordInput = document.getElementById('passwordInput');
            const error = document.getElementById('passwordError');
            const modal = document.getElementById('passwordModal');
            
            const name = nameInput.value.trim();
            const password = passwordInput.value;
            
            if (!name) {
                error.textContent = '‚ùå Please enter your name.';
                nameInput.focus();
                return;
            }
            
            if (password === TELEMETRY_CONFIG.accessPassword) {
                currentUserName = name;
                sessionStorage.setItem('authenticated', 'true');
                sessionStorage.setItem('userName', name);
                modal.classList.add('hidden');
                updateUserGreeting();
            } else {
                error.textContent = '‚ùå Incorrect password. Please try again.';
                passwordInput.value = '';
                passwordInput.focus();
            }
        }

        function updateUserGreeting() {
            if (userGreeting && currentUserName) {
                userGreeting.textContent = currentUserName;
            }
        }

        function checkAuthentication() {
            const modal = document.getElementById('passwordModal');
            const isAuthenticated = sessionStorage.getItem('authenticated') === 'true';
            const storedName = sessionStorage.getItem('userName');
            
            if (isAuthenticated && storedName) {
                currentUserName = storedName;
                modal.classList.add('hidden');
                updateUserGreeting();
            } else {
                modal.classList.remove('hidden');
                document.getElementById('loginNameInput').focus();
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            const passwordInput = document.getElementById('passwordInput');
            const nameInput = document.getElementById('loginNameInput');
            
            if (nameInput) {
                nameInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        passwordInput.focus();
                    }
                });
            }
            
            if (passwordInput) {
                passwordInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        checkPassword();
                    }
                });
            }
            
            checkAuthentication();
        });

        // ========================================
        // DATA LOADING
        // ========================================
        async function loadData() {
            try {
                const [strategiesContentData, strategiesMetadataData, filterOptionsData, accordionPresetsData] = await Promise.all([
                    fetch('strategies-content.json').then(res => res.json()),
                    fetch('strategies-metadata.json').then(res => res.json()),
                    fetch('filterOptions.json').then(res => res.json()),
                    fetch('accordionPresets.json').then(res => res.json())
                ]);

                dataVersions.strategiesContent = strategiesContentData.version || 'unversioned';
                dataVersions.strategiesMetadata = strategiesMetadataData.version || 'unversioned';
                dataVersions.filterOptions = filterOptionsData.version || 'unversioned';
                dataVersions.accordionPresets = accordionPresetsData.version || 'unversioned';
                dataVersions.loadTimestamp = new Date().toISOString();

                const strategiesContent = strategiesContentData.strategies || strategiesContentData;
                const strategiesMetadata = strategiesMetadataData.metadata || strategiesMetadataData.strategies || strategiesMetadataData;
                
                const rawFilterOptions = filterOptionsData.filters || filterOptionsData;
                filterOptions = {};
                Object.keys(rawFilterOptions).forEach(key => {
                    if (key !== 'version' && key !== 'lastUpdated') {
                        filterOptions[key] = rawFilterOptions[key];
                    }
                });
                
                accordionPresets = {};
                Object.keys(accordionPresetsData).forEach(key => {
                    if (key !== 'version' && key !== 'lastUpdated') {
                        accordionPresets[key] = accordionPresetsData[key];
                    }
                });

                allStrategies = strategiesContent.map(content => {
                    const metadata = strategiesMetadata.find(meta => meta.id === content.id);
                    return { ...content, ...metadata };
                });

                allStrategies = allStrategies.filter(strategy => 
                    strategy.title !== "Not Assigned" && 
                    strategy.overtitle !== "Not Assigned" &&
                    strategy.description !== "Not Assigned"
                );

                displayVersionInfo();
                return true;
            } catch (error) {
                console.error('Error loading data:', error);
                return false;
            }
        }

        // ========================================
        // BAND CALCULATION
        // ========================================
        function calculateBands(strategies) {
            // Separate N/A strategies (score = 0)
            const naStrategies = strategies.filter(s => s.calculatedScore === 0);
            const scoredStrategies = strategies.filter(s => s.calculatedScore > 0);

            // Sort by score descending
            scoredStrategies.sort((a, b) => b.calculatedScore - a.calculatedScore);

            const totalScored = scoredStrategies.length;
            const bands = {
                highlyLikely: [],
                likely: [],
                possible: [],
                unlikely: [],
                notApplicable: naStrategies
            };

            // Calculate target counts
            const targetCounts = {
                highlyLikely: Math.max(BAND_CONFIG.highlyLikely.minCount, Math.ceil(totalScored * BAND_CONFIG.highlyLikely.percentage)),
                likely: Math.ceil(totalScored * BAND_CONFIG.likely.percentage),
                possible: Math.ceil(totalScored * BAND_CONFIG.possible.percentage),
                unlikely: Math.ceil(totalScored * BAND_CONFIG.unlikely.percentage)
            };

            // Distribute strategies into bands
            let index = 0;
            for (const bandKey of ['highlyLikely', 'likely', 'possible', 'unlikely']) {
                const count = targetCounts[bandKey];
                bands[bandKey] = scoredStrategies.slice(index, index + count);
                index += count;
            }

            // Any remaining strategies go to unlikely
            if (index < totalScored) {
                bands.unlikely.push(...scoredStrategies.slice(index));
            }

            // Randomize order within each band
            for (const bandKey of BAND_ORDER) {
                shuffleArray(bands[bandKey]);
            }

            return { bands, targetCounts };
        }

        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        // ========================================
        // BAND MOVEMENT
        // ========================================
        function moveStrategy(strategyId, direction, requireReason = false) {
            const strategy = filteredStrategies.find(s => s.id === strategyId);
            if (!strategy) return;

            const currentBandKey = strategy.currentBand;
            const currentBandIndex = BAND_ORDER.indexOf(currentBandKey);
            const targetBandIndex = currentBandIndex + (direction === 'up' ? -1 : 1);

            if (targetBandIndex < 0 || targetBandIndex >= BAND_ORDER.length) return;

            const targetBandKey = BAND_ORDER[targetBandIndex];

            // If moving to N/A, require a reason
            if (targetBandKey === 'notApplicable' && !requireReason) {
                openNAReasonModal(strategyId, direction);
                return;
            }

            // Handle automatic balancing
            const { bands } = calculateCurrentBands();
            const targetBand = bands[targetBandKey];
            
            // For non-NA bands, enforce capacity limits with automatic swapping
            if (targetBandKey !== 'notApplicable' && currentBandKey !== 'notApplicable') {
                const targetCount = window.currentTargetCounts[targetBandKey];
                const currentInTarget = targetBand.filter(s => !pendingMoves[s.id] || pendingMoves[s.id].toBand === targetBandKey).length;
                
                if (currentInTarget >= targetCount) {
                    // Find the lowest-scoring strategy in target band that hasn't been manually moved
                    const autoMoveCandidate = targetBand
                        .filter(s => s.id !== strategyId && (!pendingMoves[s.id] || !pendingMoves[s.id].isManual))
                        .sort((a, b) => a.calculatedScore - b.calculatedScore)[0];
                    
                    if (autoMoveCandidate) {
                        // Auto-move the lowest scorer down
                        pendingMoves[autoMoveCandidate.id] = {
                            fromBand: targetBandKey,
                            toBand: BAND_ORDER[targetBandIndex + 1],
                            isManual: false,
                            oldScore: autoMoveCandidate.calculatedScore,
                            reason: null
                        };
                    }
                }
            }

            // Record the manual move
            pendingMoves[strategyId] = {
                fromBand: currentBandKey,
                toBand: targetBandKey,
                isManual: true,
                oldScore: strategy.calculatedScore,
                reason: requireReason || null
            };

            updatePendingCount();
            applyFilters();
        }

        function openNAReasonModal(strategyId, direction) {
            const strategy = filteredStrategies.find(s => s.id === strategyId);
            if (!strategy) return;

            const modal = document.createElement('div');
            modal.className = 'flag-modal';
            modal.id = 'naReasonModal';
            modal.innerHTML = `
                <div class="flag-modal-content">
                    <div class="flag-modal-title">Move to Not Applicable</div>
                    <div class="flag-modal-subtitle">${strategy.title}</div>
                    
                    <p style="margin-bottom: 16px; color: #374151;">
                        Please provide a categorical reason why this strategy cannot be applied:
                    </p>
                    
                    <textarea 
                        class="flag-textarea" 
                        id="naReasonText" 
                        placeholder="E.g., 'Requires trade mark registration which client does not have', 'Strategy only applies to patents, not copyright', etc."
                    ></textarea>
                    
                    <div class="flag-modal-buttons">
                        <button class="btn btn-secondary" onclick="closeNAReasonModal()">Cancel</button>
                        <button class="btn btn-primary" onclick="submitNAReason(${strategyId}, '${direction}')">Confirm Move</button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
        }

        function closeNAReasonModal() {
            const modal = document.getElementById('naReasonModal');
            if (modal) modal.remove();
        }

        function submitNAReason(strategyId, direction) {
            const reasonText = document.getElementById('naReasonText').value.trim();
            
            if (!reasonText) {
                alert('Please provide a reason for marking this as Not Applicable');
                return;
            }
            
            closeNAReasonModal();
            moveStrategy(strategyId, direction, reasonText);
        }

        // ========================================
        // RENDERING
        // ========================================
        function calculateCurrentBands() {
            // Apply pending moves to strategies
            const strategiesWithMoves = filteredStrategies.map(s => {
                const move = pendingMoves[s.id];
                return {
                    ...s,
                    currentBand: move ? move.toBand : s.originalBand,
                    hasPendingMove: !!move,
                    moveType: move ? (move.isManual ? 'manual' : 'auto') : null
                };
            });

            return calculateBands(strategiesWithMoves);
        }

        function renderStrategiesByBands() {
            if (filteredStrategies.length === 0) {
                strategiesContainer.innerHTML = `
                    <div class="no-results">
                        <h3>No strategies found</h3>
                        <p>Try adjusting your filters</p>
                    </div>
                `;
                return;
            }

            const { bands, targetCounts } = calculateCurrentBands();
            window.currentTargetCounts = targetCounts;

            strategiesContainer.innerHTML = '';

            BAND_ORDER.forEach(bandKey => {
                const bandConfig = BAND_CONFIG[bandKey];
                const strategies = bands[bandKey];
                const targetCount = targetCounts[bandKey] || strategies.length;

                const bandDiv = document.createElement('div');
                bandDiv.className = 'relevance-band';

                const header = document.createElement('div');
                header.className = 'band-header';
                header.innerHTML = `
                    <div class="band-title">
                        <span class="band-badge ${bandConfig.cssClass}">${bandConfig.label}</span>
                        <span class="band-count">${strategies.length} strateg${strategies.length === 1 ? 'y' : 'ies'}${bandKey !== 'notApplicable' ? ` (target: ${targetCount})` : ''}</span>
                    </div>
                `;
                bandDiv.appendChild(header);

                const grid = document.createElement('div');
                grid.className = 'strategies-grid';

                // Add actual strategy cards
                strategies.forEach(strategy => {
                    const card = createStrategyCard(strategy, bandKey);
                    grid.appendChild(card);
                });

                // Add ghost cards for non-NA bands if under target
                if (bandKey !== 'notApplicable' && strategies.length < targetCount) {
                    const ghostCount = targetCount - strategies.length;
                    for (let i = 0; i < ghostCount; i++) {
                        const ghost = document.createElement('div');
                        ghost.className = 'strategy-card ghost';
                        ghost.innerHTML = '<div class="card-header">Empty slot</div>';
                        grid.appendChild(ghost);
                    }
                }

                bandDiv.appendChild(grid);
                strategiesContainer.appendChild(bandDiv);
            });
        }

        function createStrategyCard(strategy, bandKey) {
            const card = document.createElement('div');
            card.className = 'strategy-card';

            const move = pendingMoves[strategy.id];
            if (move) {
                card.classList.add(move.isManual ? 'manually-moved' : 'auto-moved');
            }

            const bandIndex = BAND_ORDER.indexOf(bandKey);
            const canMoveUp = bandIndex > 0;
            const canMoveDown = bandIndex < BAND_ORDER.length - 1;

            const isFlagged = isStrategyFlagged(strategy.id);

            card.innerHTML = `
                ${move ? `<div class="move-badge ${move.isManual ? '' : 'auto'}">${move.isManual ? 'MOVED' : 'AUTO'}</div>` : ''}
                <div class="card-header">
                    ${strategy.overtitle ? `<div class="card-overtitle">${strategy.overtitle}</div>` : ''}
                    <div class="card-title">${strategy.title}</div>
                    <div class="card-description">${strategy.description}</div>
                    <div class="card-score">Score: ${strategy.calculatedScore.toFixed(1)}</div>
                </div>
                <div class="card-controls">
                    <div class="movement-buttons">
                        <button class="move-btn" onclick="moveStrategy(${strategy.id}, 'up')" ${!canMoveUp ? 'disabled' : ''} title="Move to higher relevance band">‚ñ≤</button>
                        <button class="move-btn" onclick="moveStrategy(${strategy.id}, 'down')" ${!canMoveDown ? 'disabled' : ''} title="Move to lower relevance band">‚ñº</button>
                    </div>
                    <button class="flag-button ${isFlagged ? 'flagged' : ''}" onclick="openFlagModal(${strategy.id})">
                        ${isFlagged ? '‚úì Flagged' : 'üö© Flag'}
                    </button>
                </div>
            `;

            return card;
        }

        // ========================================
        // FILTER MANAGEMENT
        // ========================================
        function getAccordionLayout() {
            const selectedSituation = situationFilter.value;
            const selectedIPRight = ipRightsFilter.value;
            
            if (!selectedSituation && !selectedIPRight) {
                return accordionPresets.default || accordionPresets['default'];
            }
            
            const ipRightMap = {
                'Patent': 'patents',
                'Trade mark': 'trademarks',
                'Design': 'designs',
                'PBR': 'pbr',
                'Copyright': 'copyright',
                'Any dispute': 'any'
            };
            
            const situationMap = {
                'Enforcement': 'enforcement',
                'Accused': 'accused',
                'Proactive': 'proactive',
                'Disagree': 'disagree'
            };
            
            let presetKey = '';
            
            if (selectedIPRight && selectedSituation) {
                const ipKey = ipRightMap[selectedIPRight] || 'uncertain';
                const situationKey = situationMap[selectedSituation] || '';
                presetKey = `${ipKey}-${situationKey}`;
            } else if (selectedSituation) {
                const situationKey = situationMap[selectedSituation] || '';
                presetKey = `any-${situationKey}`;
            } else if (selectedIPRight) {
                return accordionPresets.default || accordionPresets['default'];
            }
            
            const layout = accordionPresets[presetKey];
            
            if (layout) {
                console.log(`Using accordion preset: ${presetKey}`);
                return layout;
            } else {
                console.log(`Preset '${presetKey}' not found, using default`);
                return accordionPresets.default || accordionPresets['default'];
            }
        }

        function renderAccordions() {
            accordionContainer.innerHTML = '';
            
            const layout = getAccordionLayout();
            const accordions = layout.accordions || {};
            const topFilters = layout.topFilters || [];

            function isFilterActive(filterKey, optionIndex) {
                return activeFilters.some(f => f.key === filterKey && f.optionIndex === optionIndex);
            }

            function hasActiveFilterInGroup(filterKeys) {
                return filterKeys.some(key => 
                    activeFilters.some(f => f.key === key)
                );
            }

            if (topFilters.length > 0) {
                const topFiltersKey = 'topfilters';
                const hasActiveTopFilter = hasActiveFilterInGroup(topFilters);
                
                const topHeader = document.createElement('div');
                topHeader.className = 'accordion-header';
                const activeText = hasActiveTopFilter ? ' ‚úì' : '';
                
                topHeader.innerHTML = `
                    <span style="display:inline-block; transition: transform 0.3s ease; transform: ${accordionState[topFiltersKey] ? 'rotate(90deg)' : 'rotate(0deg)'};">‚ñ∂</span>
                    Additional Filters${activeText}
                `;
                
                topHeader.onclick = () => {
                    accordionState[topFiltersKey] = !accordionState[topFiltersKey];
                    renderAccordions();
                };
                
                accordionContainer.appendChild(topHeader);

                if (accordionState[topFiltersKey]) {
                    const topContent = document.createElement('div');
                    topContent.className = 'accordion-content';
                    
                    topFilters.forEach(filterKey => {
                        const filterConfig = filterOptions[filterKey];
                        if (!filterConfig) return;

                        const group = document.createElement('div');
                        group.style.marginBottom = '20px';

                        const label = document.createElement('div');
                        label.className = 'filter-label';
                        label.textContent = filterConfig.label;
                        group.appendChild(label);

                        const radioGroup = document.createElement('div');
                        radioGroup.className = 'radio-group';

                        filterConfig.options.forEach((option, index) => {
                            const radio = document.createElement('div');
                            radio.className = 'radio-button';
                            
                            if (isFilterActive(filterKey, index)) {
                                radio.classList.add('radio-selected');
                            }
                            
                            radio.textContent = option.label;
                            radio.onclick = () => {
                                const newFilter = {
                                    key: filterKey,
                                    optionIndex: index,
                                    config: filterConfig,
                                    option: option
                                };
                                
                                const existingIndex = activeFilters.findIndex(
                                    f => f.key === filterKey && f.optionIndex === index
                                );
                                
                                if (existingIndex !== -1) {
                                    activeFilters.splice(existingIndex, 1);
                                } else {
                                    activeFilters = activeFilters.filter(f => f.key !== filterKey);
                                    activeFilters.push(newFilter);
                                }
                                
                                applyFilters();
                                renderAccordions();
                            };
                            radioGroup.appendChild(radio);
                        });

                        group.appendChild(radioGroup);
                        topContent.appendChild(group);
                    });
                    
                    accordionContainer.appendChild(topContent);
                }
            }

            Object.entries(accordions).forEach(([accordionTitle, filterKeys]) => {
                const accordionKey = accordionTitle.toLowerCase().replace(/\s+/g, '');
                const hasActiveFilter = hasActiveFilterInGroup(filterKeys);
                
                const header = document.createElement('div');
                header.className = 'accordion-header';
                const activeText = hasActiveFilter ? ' ‚úì' : '';
                
                header.innerHTML = `
                    <span style="display:inline-block; transition: transform 0.3s ease; transform: ${accordionState[accordionKey] ? 'rotate(90deg)' : 'rotate(0deg)'};">‚ñ∂</span>
                    ${accordionTitle}${activeText}
                `;
                
                header.onclick = () => {
                    accordionState[accordionKey] = !accordionState[accordionKey];
                    renderAccordions();
                };
                
                accordionContainer.appendChild(header);

                if (accordionState[accordionKey]) {
                    const content = document.createElement('div');
                    content.className = 'accordion-content';

                    filterKeys.forEach(filterKey => {
                        const filterConfig = filterOptions[filterKey];
                        if (!filterConfig) return;

                        const group = document.createElement('div');
                        group.style.marginBottom = '16px';

                        const label = document.createElement('div');
                        label.className = 'filter-label';
                        label.textContent = filterConfig.label;
                        group.appendChild(label);

                        const radioGroup = document.createElement('div');
                        radioGroup.className = 'radio-group';

                        filterConfig.options.forEach((option, index) => {
                            const radio = document.createElement('div');
                            radio.className = 'radio-button';
                            
                            if (isFilterActive(filterKey, index)) {
                                radio.classList.add('radio-selected');
                            }
                            
                            radio.textContent = option.label;
                            radio.onclick = () => {
                                const newFilter = {
                                    key: filterKey,
                                    optionIndex: index,
                                    config: filterConfig,
                                    option: option
                                };
                                
                                const existingIndex = activeFilters.findIndex(
                                    f => f.key === filterKey && f.optionIndex === index
                                );
                                
                                if (existingIndex !== -1) {
                                    activeFilters.splice(existingIndex, 1);
                                } else {
                                    activeFilters = activeFilters.filter(f => f.key !== filterKey);
                                    activeFilters.push(newFilter);
                                }
                                
                                applyFilters();
                                renderAccordions();
                            };
                            radioGroup.appendChild(radio);
                        });

                        group.appendChild(radioGroup);
                        content.appendChild(group);
                    });

                    accordionContainer.appendChild(content);
                }
            });
        }

        function applyFilters() {
            const selectedSituation = situationFilter.value;
            const selectedIPRight = ipRightsFilter.value;

            filteredStrategies = allStrategies.filter(strategy => {
                if (selectedSituation && strategy.responseType) {
                    if (!strategy.responseType.includes(selectedSituation)) {
                        return false;
                    }
                }

                if (selectedIPRight && strategy.ipTypeTags) {
                    if (!strategy.ipTypeTags.includes(selectedIPRight) && 
                        !strategy.ipTypeTags.includes('Any dispute')) {
                        return false;
                    }
                }

                return true;
            });

            filteredStrategies = filteredStrategies.map(strategy => {
                let score = 1.0;
                
                activeFilters.forEach(filter => {
                    if (filterOptions[filter.key]) {
                        const option = filter.option;
                        if (option && option.scoringValues && strategy.id <= option.scoringValues.length) {
                            const filterScore = option.scoringValues[strategy.id - 1] || 1.0;
                            score *= filterScore;
                        }
                    }
                });
                
                return {
                    ...strategy,
                    calculatedScore: Math.round(score * 10) / 10
                };
            });

            // Assign original bands
            const { bands } = calculateBands(filteredStrategies);
            for (const [bandKey, strategies] of Object.entries(bands)) {
                strategies.forEach(s => s.originalBand = bandKey);
            }

            updateActiveFilterDisplay();
            updateResultsCount();
            renderStrategiesByBands();
        }

        function updateActiveFilterDisplay() {
            activeFilterPill.innerHTML = '';

            if (activeFilters.length > 0) {
                activeFilters.forEach((filter, index) => {
                    const config = filter.config;
                    const option = filter.option;
                    
                    let pillText = config.pillTemplate || `${config.label}: ${option.label}`;
                    pillText = pillText.replace('{optionLabel}', option.pillLabel || option.label);

                    const pill = document.createElement('div');
                    pill.className = 'active-filter-pill';
                    pill.style.marginRight = '8px';
                    pill.style.marginBottom = '8px';
                    pill.innerHTML = `
                        <span>${pillText}</span>
                        <button onclick="clearSpecificFilter(${index})">√ó</button>
                    `;
                    activeFilterPill.appendChild(pill);
                });
            }
        }

        function clearSpecificFilter(index) {
            activeFilters.splice(index, 1);
            applyFilters();
            renderAccordions();
        }

        function clearAllFilters() {
            situationFilter.value = '';
            ipRightsFilter.value = '';
            activeFilters = [];
            accordionState = {};
            applyFilters();
            renderAccordions();
        }

        function updateResultsCount() {
            resultsCount.textContent = `${filteredStrategies.length} strategies`;
        }

        // ========================================
        // PENDING CHANGES MANAGEMENT
        // ========================================
        function updatePendingCount() {
            const count = Object.keys(pendingMoves).length;
            pendingCount.textContent = count;
            submitChangesBtn.disabled = count === 0;
        }

        async function submitAllChanges() {
            if (Object.keys(pendingMoves).length === 0) return;

            const filterState = collectFilterState();
            const moves = Object.entries(pendingMoves);

            let successCount = 0;

            for (const [strategyId, move] of moves) {
                const strategy = filteredStrategies.find(s => s.id === parseInt(strategyId));
                if (!strategy) continue;

                // Calculate approximate target score for the new band
                const targetBandIndex = BAND_ORDER.indexOf(move.toBand);
                let targetScore = move.oldScore;
                
                // Adjust score based on band
                if (move.toBand === 'notApplicable') {
                    targetScore = 0;
                } else {
                    // Use a multiplier based on band position
                    const multipliers = [1.5, 1.2, 1.0, 0.8, 0];
                    targetScore = move.oldScore * multipliers[targetBandIndex];
                }

                const telemetryData = {
                    strategyId: strategy.id,
                    strategyTitle: strategy.title,
                    oldBand: BAND_CONFIG[move.fromBand].label,
                    newBand: BAND_CONFIG[move.toBand].label,
                    oldScore: move.oldScore,
                    newScore: Math.round(targetScore * 10) / 10,
                    moveType: move.isManual ? 'manual' : 'automatic',
                    reason: move.reason || ''
                };

                const success = await sendTelemetry(telemetryData, filterState);
                if (success) successCount++;
            }

            if (successCount > 0) {
                alert(`‚úÖ Successfully submitted ${successCount} change${successCount === 1 ? '' : 's'}!`);
                pendingMoves = {};
                updatePendingCount();
                applyFilters();
            }
        }

        function collectFilterState() {
            const accordionFiltersArray = activeFilters.map(filter => ({
                key: filter.key,
                option: filter.option.label
            }));
            
            return {
                situationFilter: situationFilter.value || 'All Situations',
                ipRightsFilter: ipRightsFilter.value || 'All IP Rights',
                accordionFilters: JSON.stringify(accordionFiltersArray)
            };
        }

        async function sendTelemetry(telemetryData, filterState) {
            if (!currentUserName) {
                alert('User name not found. Please refresh and log in again.');
                return false;
            }
            
            const payload = {
                userName: currentUserName,
                situationFilter: filterState.situationFilter,
                ipRightsFilter: filterState.ipRightsFilter,
                accordionFilters: filterState.accordionFilters,
                strategyId: telemetryData.strategyId,
                strategyTitle: telemetryData.strategyTitle,
                oldBand: telemetryData.oldBand,
                newBand: telemetryData.newBand,
                oldScore: telemetryData.oldScore,
                newScore: telemetryData.newScore,
                moveType: telemetryData.moveType,
                reason: telemetryData.reason,
                sessionId: TELEMETRY_CONFIG.sessionId,
                strategiesVersion: dataVersions.strategiesContent,
                metadataVersion: dataVersions.strategiesMetadata,
                filtersVersion: dataVersions.filterOptions,
                presetsVersion: dataVersions.accordionPresets,
                dataLoadTimestamp: dataVersions.loadTimestamp
            };
            
            try {
                await fetch(TELEMETRY_CONFIG.sheetURL, {
                    method: 'POST',
                    mode: 'no-cors',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(payload)
                });
                
                return true;
                
            } catch (error) {
                console.error('Error sending telemetry:', error);
                return false;
            }
        }

        // ========================================
        // FLAG MODAL
        // ========================================
        let currentFlagStrategy = null;

        function openFlagModal(strategyId) {
            const strategy = filteredStrategies.find(s => s.id === strategyId);
            if (!strategy) return;
            
            currentFlagStrategy = strategy;
            
            const modal = document.createElement('div');
            modal.className = 'flag-modal';
            modal.id = 'flagModal';
            modal.innerHTML = `
                <div class="flag-modal-content">
                    <div class="flag-modal-title">${strategy.title}</div>
                    <div class="flag-modal-subtitle">Current Band: ${BAND_CONFIG[strategy.currentBand || strategy.originalBand].label} | Score: ${strategy.calculatedScore}</div>
                    
                    <div style="margin-bottom: 12px; font-weight: 600; color: #374151;">
                        What issue did you notice?
                    </div>
                    
                    <div class="flag-option" data-value="other">
                        üí≠ General feedback or issue
                    </div>
                    
                    <textarea 
                        class="flag-textarea" 
                        id="flagFeedback" 
                        placeholder="Please describe the issue or provide feedback..."
                    ></textarea>
                    
                    <div class="flag-modal-buttons">
                        <button class="btn btn-secondary" onclick="closeFlagModal()">Cancel</button>
                        <button class="btn btn-primary" onclick="submitFlag()">Submit Feedback</button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            const options = modal.querySelectorAll('.flag-option');
            options.forEach(option => {
                option.addEventListener('click', function() {
                    options.forEach(o => o.classList.remove('selected'));
                    this.classList.add('selected');
                });
            });
            
            // Auto-select the option
            options[0].classList.add('selected');
        }

        function closeFlagModal() {
            const modal = document.getElementById('flagModal');
            if (modal) modal.remove();
            currentFlagStrategy = null;
        }

        async function submitFlag() {
            const feedbackText = document.getElementById('flagFeedback').value.trim();
            
            if (!feedbackText) {
                alert('Please provide feedback details');
                return;
            }
            
            const filterState = collectFilterState();
            const telemetryData = {
                strategyId: currentFlagStrategy.id,
                strategyTitle: currentFlagStrategy.title,
                oldBand: BAND_CONFIG[currentFlagStrategy.currentBand || currentFlagStrategy.originalBand].label,
                newBand: '',
                oldScore: currentFlagStrategy.calculatedScore,
                newScore: '',
                moveType: 'flag',
                reason: feedbackText
            };
            
            const success = await sendTelemetry(telemetryData, filterState);
            
            if (success) {
                alert('‚úÖ Feedback submitted successfully!');
                closeFlagModal();
                markStrategyAsFlagged(currentFlagStrategy.id);
            }
        }

        function markStrategyAsFlagged(strategyId) {
            const sessionFlags = JSON.parse(sessionStorage.getItem('flaggedStrategies') || '[]');
            if (!sessionFlags.includes(strategyId)) {
                sessionFlags.push(strategyId);
                sessionStorage.setItem('flaggedStrategies', JSON.stringify(sessionFlags));
            }
            applyFilters();
        }

        function isStrategyFlagged(strategyId) {
            const sessionFlags = JSON.parse(sessionStorage.getItem('flaggedStrategies') || '[]');
            return sessionFlags.includes(strategyId);
        }

        // ========================================
        // EVENT LISTENERS
        // ========================================
        function setupEventListeners() {
            situationFilter.addEventListener('change', () => {
                applyFilters();
                renderAccordions();
            });
            ipRightsFilter.addEventListener('change', () => {
                applyFilters();
                renderAccordions();
            });
            clearFilters.addEventListener('click', clearAllFilters);
            submitChangesBtn.addEventListener('click', submitAllChanges);
        }

        // Make functions globally available
        window.moveStrategy = moveStrategy;
        window.submitNAReason = submitNAReason;
        window.closeNAReasonModal = closeNAReasonModal;
        window.clearSpecificFilter = clearSpecificFilter;
        window.openFlagModal = openFlagModal;
        window.closeFlagModal = closeFlagModal;
        window.submitFlag = submitFlag;
        window.checkPassword = checkPassword;

        // ========================================
        // INITIALIZATION
        // ========================================
        async function init() {
            const dataLoaded = await loadData();
            
            if (!dataLoaded) {
                strategiesContainer.innerHTML = `
                    <div class="no-results">
                        <h3>Failed to load data</h3>
                        <p>Please check that all data is available</p>
                    </div>
                `;
                return;
            }

            setupEventListeners();
            renderAccordions();
            applyFilters();
        }

        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
