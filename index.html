<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Navigator Review Platform</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
           
            background: linear-gradient(135deg, #7B93A8 0%, #2C3E50 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 16px;
            padding: 24px;
            margin-bottom: 24px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }

        .header h1 {
            font-size: 2.2rem;
            font-weight: 700;
            background: linear-gradient(135deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 8px;
        }

        .header p {
            color: #666;
            font-size: 1.1rem;
            margin-bottom: 16px;
        }

        .header-controls {
            display: grid;
            grid-template-columns: 1fr 1fr 250px;
            gap: 24px;
            align-items: end;
            margin-top: 20px;
        }

        .user-greeting {
            display: flex;
            align-items: center;
            font-weight: 600;
            color: #374151;
            font-size: 16px;
        }

        .primary-filters {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 16px;
        }

        .filter-group {
            display: flex;
            flex-direction: column;
        }

        .filter-label {
            font-weight: 600;
            margin-bottom: 8px;
            color: #374151;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        select {
            padding: 12px 16px;
            border: 2px solid #e1e5e9;
            border-radius: 8px;
            font-size: 14px;
            transition: all 0.3s ease;
            background: white;
        }

        select:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .top-controls {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 8px;
        }

        .results-count {
            font-weight: 600;
            color: #374151;
            font-size: 14px;
        }

        .control-buttons {
            display: flex;
            gap: 8px;
        }

        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 13px;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }

        .btn-secondary {
            background: #f8f9fa;
            color: #495057;
            border: 2px solid #e9ecef;
        }

        .btn-secondary:hover {
            background: #e9ecef;
            transform: translateY(-1px);
        }

        .main-layout {
            display: grid;
            grid-template-columns: 350px 1fr;
            gap: 24px;
            align-items: start;
        }

        .sidebar {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 16px;
            padding: 24px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            position: sticky;
            top: 20px;
            max-height: calc(100vh - 40px);
            overflow-y: auto;
        }

        .content-area {
            min-width: 0;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 16px;
            padding: 24px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }

        .active-filter-pill {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 12px 20px;
            border-radius: 25px;
            font-size: 16px;
            font-weight: 600;
            display: inline-flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 20px;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }

        .active-filter-pill button {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            cursor: pointer;
            font-size: 18px;
            padding: 4px 8px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            width: 24px;
            height: 24px;
        }

        .active-filter-pill button:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.1);
        }

        .accordion-header {
            background: #f8f9fa;
            padding: 12px 16px;
            border-radius: 8px;
            cursor: pointer;
            margin-bottom: 8px;
            font-weight: 600;
            transition: all 0.3s ease;
            border: 2px solid transparent;
        }

        .accordion-header:hover {
            background: #e9ecef;
            border-color: #667eea;
        }

        .accordion-content {
            background: white;
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 16px;
            border: 1px solid #e1e5e9;
        }

        .radio-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .radio-button {
            padding: 12px 16px;
            border: 2px solid #e1e5e9;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            background: white;
            font-size: 14px;
            font-weight: 500;
            user-select: none;
        }

        .radio-button:hover {
            background: #f8f9fa;
            border-color: #667eea;
            transform: translateY(-1px);
        }

        .radio-button.radio-selected {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border-color: #667eea;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
        }

        .review-status-badge {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 10px;
            font-weight: 600;
            margin-left: 8px;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }

        .review-status-badge.not-reviewed {
            background: #fef3c7;
            color: #92400e;
        }

        .review-status-badge.few-reviews {
            background: #fed7aa;
            color: #7c2d12;
        }

        .review-status-badge.many-reviews {
            background: #d1fae5;
            color: #065f46;
        }

        /* RANK-BASED LAYOUT */
        .rank-group {
            margin-bottom: 32px;
        }

        .rank-header {
            background: #f8f9fa;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            padding: 12px 20px;
            margin-bottom: 16px;
            font-weight: 700;
            font-size: 16px;
            color: #374151;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .rank-title {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .rank-badge {
            color: white;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: 600;
        }

        .rank-badge.more-likely {
            background: #10b981;
        }

        .rank-badge.no-effect {
            background: #6b7280;
        }

        .rank-badge.less-likely {
            background: #f59e0b;
        }

        .rank-badge.not-applicable {
            background: #ef4444;
        }

        .rank-count {
            font-size: 14px;
            color: #6b7280;
            font-weight: 500;
        }

        .strategies-row {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 16px;
        }

        .strategy-card {
            background: white;
            border: 2px solid #e1e5e9;
            border-radius: 12px;
            padding: 16px;
            transition: all 0.3s ease;
            position: relative;
            min-height: 320px;
            display: flex;
            flex-direction: column;
        }

        .strategy-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.1);
            border-color: #667eea;
        }

        .strategy-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: linear-gradient(135deg, #667eea, #764ba2);
        }

.status-badge {
    display: block;
    padding: 4px 8px;
    border-radius: 4px;
    font-size: 11px;
    font-weight: 700;
    margin-bottom: 8px;
    text-align: center;
}

        .status-badge.pending {
            background: #fef3c7;
            color: #92400e;
        }

        .status-badge.submitted {
            background: #d1fae5;
            color: #065f46;
        }

        .card-header {
            margin-bottom: 12px;
            flex: 1;
        }

        .card-overtitle {
            font-size: 11px;
            color: #667eea;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 4px;
        }

        .card-title {
            font-size: 1rem;
            font-weight: 700;
            color: #1f2937;
            margin-bottom: 8px;
            line-height: 1.3;
        }

        .card-description {
            color: #6b7280;
            line-height: 1.4;
            font-size: 13px;
            margin-bottom: 8px;
        }

        .card-link {
            color: #667eea;
            font-size: 12px;
            text-decoration: none;
            font-weight: 600;
        }

        .card-link:hover {
            text-decoration: underline;
        }

        .card-controls {
            border-top: 1px solid #e5e7eb;
            padding-top: 12px;
        }

        .score-control {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 8px;
        }

        .score-input {
            background: #f3f4f6;
            color: #374151;
            border: 1px solid #d1d5db;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 13px;
            font-weight: 600;
            width: 50px;
            text-align: center;
            -moz-appearance: textfield;
        }

        .score-input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 2px rgba(102, 126, 234, 0.1);
        }

        .score-input::-webkit-outer-spin-button,
        .score-input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        .score-buttons {
            display: flex;
            gap: 4px;
            align-items: center;
        }

        .score-btn {
            background: #667eea;
            color: white;
            border: none;
            border-radius: 4px;
            width: 24px;
            height: 24px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            transition: all 0.2s ease;
        }

        .score-btn:hover {
            background: #5a6fd8;
            transform: scale(1.1);
        }

        .score-btn:disabled {
            background: #d1d5db;
            cursor: not-allowed;
            transform: none;
        }

        .na-btn {
            background: #9ca3af;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 2px 6px;
            cursor: pointer;
            font-size: 10px;
            font-weight: 600;
            margin-left: 4px;
            transition: all 0.2s ease;
        }

        .na-btn:hover {
            background: #6b7280;
        }

        .na-btn.active {
            background: #ef4444;
        }

        .reason-input {
            width: 100%;
            padding: 8px;
            border: 2px solid #e1e5e9;
            border-radius: 6px;
            resize: vertical;
            min-height: 60px;
            font-size: 12px;
            font-family: inherit;
            margin-top: 8px;
        }

        .reason-input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .reason-input::placeholder {
            color: #9ca3af;
        }

        .submit-reason-btn {
            width: 100%;
            margin-top: 8px;
            padding: 6px 12px;
            background: #10b981;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
            transition: all 0.2s ease;
        }

        .submit-reason-btn:hover {
            background: #059669;
        }

        .submit-reason-btn:disabled {
            background: #d1d5db;
            cursor: not-allowed;
        }

        .undo-btn {
            width: 100%;
            margin-top: 4px;
            padding: 6px 12px;
            background: #f59e0b;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
            transition: all 0.2s ease;
        }

        .undo-btn:hover {
            background: #d97706;
        }

        .no-changes-btn {
            width: 100%;
            margin-top: 8px;
            padding: 6px 12px;
            background: #6b7280;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
            transition: all 0.2s ease;
        }

        .no-changes-btn:hover {
            background: #4b5563;
        }

        .validation-error {
            background: #fef2f2;
            border: 2px solid #fca5a5;
            color: #dc2626;
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 16px;
            font-size: 14px;
            font-weight: 600;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #666;
        }

        .no-results {
            text-align: center;
            padding: 60px 40px;
            color: #666;
        }

        .password-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
        }

        .password-content {
            background: white;
            border-radius: 16px;
            padding: 40px;
            max-width: 400px;
            text-align: center;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        }

        .password-content h2 {
            margin-bottom: 16px;
            color: #374151;
        }

        .password-content p {
            margin-bottom: 20px;
            color: #6b7280;
        }

        .password-content input,
        .password-content select {
            width: 100%;
            padding: 12px 16px;
            border: 2px solid #e1e5e9;
            border-radius: 8px;
            font-size: 16px;
            margin-bottom: 16px;
        }

        .password-content input:focus,
        .password-content select:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .password-error {
            color: #dc2626;
            margin-top: 12px;
            font-weight: 600;
        }

        .password-modal.hidden {
            display: none;
        }

        .btn-primary {
            background: #667eea;
            color: white;
            border: 1px solid #667eea;
            padding: 12px 24px;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 14px;
        }

        .btn-primary:hover {
            background: #5a6fd8;
            transform: translateY(-1px);
        }
        .btn-primary:disabled {
    background: #d1d5db;
    color: #9ca3af;
    border: 1px solid #d1d5db;
    cursor: not-allowed;
    transform: none;
}
        .header-instructions {
    max-width: 800px; /* Prevents text from spanning the whole screen */
    line-height: 1.5;
    color: #4b5563;
    font-size: 1rem;
    margin-bottom: 20px;
}
    </style>
</head>
    
<body>
    <!-- Password Protection Modal with User Type -->
    <div id="passwordModal" class="password-modal">
        <div class="password-content">
            <h2>üîí Access Required</h2>
            <p>Please enter your details to access the review tool:</p>
            <input type="text" id="loginNameInput" placeholder="Your name" />
            <select id="userTypeSelect">
                <option value="">Select your role...</option>
                <option value="IP Australia employee">IP Australia employee</option>
                <option value="IP professional">IP professional</option>
                <option value="Other government agency">Other government agency</option>
                <option value="Other">Other</option>
            </select>
            <input type="password" id="passwordInput" placeholder="Password" />
            <button class="btn-primary" onclick="checkPassword()">Submit</button>
            <div id="passwordError" class="password-error"></div>
        </div>
    </div>

    <div class="container">
        <div class="header">
            <h1>IP First Response - Navigator Review Platform</h1>
<p class="header-instructions">
        Help us fine-tune the IP First Response Navigator:<br><br>
        1. Select a filter from the sidebar.<br>
        2. Review the strategies and adjust their relevance (More, Less, or No Effect).<br>
        3. Submit your changes for implementation into the live tool.
    </p>            <div id="versionDisplay"></div>
            
            <div class="header-controls">
                <div class="user-greeting">
                    üë§ <span id="userGreeting">Loading...</span>
                </div>
                
                <div class="primary-filters">
                    <div class="filter-group">
                        <label class="filter-label">Situation Type</label>
                        <select id="situationFilter">
                            <option value="">All Situations</option>
                            <option value="Enforcement">I believe my IP has been infringed</option>
                            <option value="Accused">I've been accused of infringement</option>
                            <option value="Disagree">I want to understand how IP works</option>
                            <option value="Proactive">I want to prevent future IP headaches</option>
                        </select>
                    </div>
                    <div class="filter-group">
                        <label class="filter-label">IP Rights Type</label>
                        <select id="ipRightsFilter">
                            <option value="">All IP Rights</option>
                            <option value="Patent">Patents</option>
                            <option value="Trade mark">Trade marks</option>
                             <option value="Unregistered-tm">Unegistered trade marks</option>
                            <option value="Design">Design rights</option>
                            <option value="PBR">Plant breeder's rights</option>
                            <option value="Copyright">Copyright</option>
                            <option value="Any dispute">Any IP right</option>
                            <option value="OtherRights">Other rights</option>
                        </select>
                    </div>
                </div>

                <div class="top-controls">
                    <div class="results-count" id="resultsCount">Loading...</div>
                    <div class="control-buttons">
                        <button class="btn btn-secondary" id="clearFilters">üóëÔ∏è Clear</button>
                        <button class="btn btn-primary" id="bulkNoChanges">‚úì All Correct, No Changes</button>

                    </div>
                </div>
            </div>
        </div>

        <div class="main-layout">
            <div class="sidebar">
                <div id="accordionContainer"></div>
            </div>

            <div class="content-area">
                <div id="activeFilterPill"></div>
                <div id="pendingChangesWarning" style="display: none;" class="validation-error">
    ‚ö†Ô∏è You have unsubmitted changes. Find any cards you moved and submit them.
</div>
                <div id="validationError" class="validation-error" style="display: none;"></div>
                <div id="strategiesContainer">
                    <div class="loading">Loading strategy data...</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ========================================
        // CONFIGURATION
        // ========================================
        const MAX_RANKS_ABOVE_1_2 = 2;

        // Application state
        let allStrategies = [];
        let filteredStrategies = [];
        let activeFilters = [];
        let accordionState = {};
        let filterOptions = {};
        let accordionPresets = {};
        let filterReviewStatus = {}; // Track which filters have been reviewed
        let currentUserName = '';
        let currentUserType = '';
        let originalScores = {}; // Store original calculated scores
        let pendingChanges = {}; // { strategyId: { oldScore, newScore, reason, status } }
        let submittedChanges = new Set(); // Track submitted strategy IDs for this session

        const dataVersions = {
            strategiesContent: null,
            strategiesMetadata: null,
            filterOptions: null,
            accordionPresets: null,
            filterReviewStatus: null,
            loadTimestamp: null
        };

        // DOM elements
        const userGreeting = document.getElementById('userGreeting');
        const situationFilter = document.getElementById('situationFilter');
        const ipRightsFilter = document.getElementById('ipRightsFilter');
        const clearFilters = document.getElementById('clearFilters');
        const resultsCount = document.getElementById('resultsCount');
        const accordionContainer = document.getElementById('accordionContainer');
        const activeFilterPill = document.getElementById('activeFilterPill');
        const strategiesContainer = document.getElementById('strategiesContainer');
        const validationError = document.getElementById('validationError');

        // ========================================
        // TELEMETRY CONFIGURATION
        // ========================================
        const TELEMETRY_CONFIG = {
            sheetURL: 'https://default1eae4a1dfcf54be981d4b609764048.37.environment.api.powerplatform.com:443/powerautomate/automations/direct/workflows/f34918091edd49bcb2f5a247d681bf63/triggers/manual/paths/invoke?api-version=1',
            accessPassword: 'ipnavigator2024',
            sessionId: generateSessionId()
        };

        function generateSessionId() {
            return 'session_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        }

        // Display version info
        function displayVersionInfo() {
            const versionDisplay = document.getElementById('versionDisplay');
            if (versionDisplay && dataVersions.strategiesContent) {
                versionDisplay.innerHTML = `
                    <div style="font-size: 11px; color: #6b7280; margin-top: 8px;">
                        <strong>Data Versions:</strong> 
                        Strategies: ${dataVersions.strategiesContent} | 
                        Metadata: ${dataVersions.strategiesMetadata} | 
                        Filters: ${dataVersions.filterOptions} | 
                        Presets: ${dataVersions.accordionPresets} | 
                        Reviews: ${dataVersions.filterReviewStatus}
                    </div>
                `;
            }
        }

        // ========================================
        // PASSWORD PROTECTION
        // ========================================
        function checkPassword() {
            const nameInput = document.getElementById('loginNameInput');
            const userTypeSelect = document.getElementById('userTypeSelect');
            const passwordInput = document.getElementById('passwordInput');
            const error = document.getElementById('passwordError');
            const modal = document.getElementById('passwordModal');
            
            const name = nameInput.value.trim();
            const userType = userTypeSelect.value;
            const password = passwordInput.value;
            
            if (!name) {
                error.textContent = '‚ùå Please enter your name.';
                nameInput.focus();
                return;
            }

            if (!userType) {
                error.textContent = '‚ùå Please select your role.';
                userTypeSelect.focus();
                return;
            }
            
            if (password === TELEMETRY_CONFIG.accessPassword) {
                currentUserName = name;
                currentUserType = userType;
                sessionStorage.setItem('authenticated', 'true');
                sessionStorage.setItem('userName', name);
                sessionStorage.setItem('userType', userType);
                modal.classList.add('hidden');
                updateUserGreeting();
            } else {
                error.textContent = '‚ùå Incorrect password. Please try again.';
                passwordInput.value = '';
                passwordInput.focus();
            }
        }

        function updateUserGreeting() {
            if (userGreeting && currentUserName) {
                userGreeting.textContent = `${currentUserName} (${currentUserType})`;
            }
        }

        function checkAuthentication() {
            const modal = document.getElementById('passwordModal');
            const isAuthenticated = sessionStorage.getItem('authenticated') === 'true';
            const storedName = sessionStorage.getItem('userName');
            const storedType = sessionStorage.getItem('userType');
            
            if (isAuthenticated && storedName && storedType) {
                currentUserName = storedName;
                currentUserType = storedType;
                modal.classList.add('hidden');
                updateUserGreeting();
            } else {
                modal.classList.remove('hidden');
                document.getElementById('loginNameInput').focus();
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            const passwordInput = document.getElementById('passwordInput');
            const nameInput = document.getElementById('loginNameInput');
            const userTypeSelect = document.getElementById('userTypeSelect');
            
            if (nameInput) {
                nameInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        userTypeSelect.focus();
                    }
                });
            }

            if (userTypeSelect) {
                userTypeSelect.addEventListener('change', () => {
                    passwordInput.focus();
                });
            }
            
            if (passwordInput) {
                passwordInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        checkPassword();
                    }
                });
            }
            
            checkAuthentication();
        });

        // ========================================
        // DATA LOADING
        // ========================================
        async function loadData() {
            try {
                const [strategiesContentData, strategiesMetadataData, filterOptionsData, accordionPresetsData, filterReviewData] = await Promise.all([
                    fetch('strategies-content.json').then(res => res.json()),
                    fetch('strategies-metadata.json').then(res => res.json()),
                    fetch('filterOptions.json').then(res => res.json()),
                    fetch('accordionPresets.json').then(res => res.json()),
                    fetch('filter-review-status.json').then(res => res.json()).catch(() => ({ filters: {} })) // Optional file
                ]);

                dataVersions.strategiesContent = strategiesContentData.version || 'unversioned';
                dataVersions.strategiesMetadata = strategiesMetadataData.version || 'unversioned';
                dataVersions.filterOptions = filterOptionsData.version || 'unversioned';
                dataVersions.accordionPresets = accordionPresetsData.version || 'unversioned';
                dataVersions.filterReviewStatus = filterReviewData.version || 'unversioned';
                dataVersions.loadTimestamp = new Date().toISOString();

                const strategiesContent = strategiesContentData.strategies || strategiesContentData;
                const strategiesMetadata = strategiesMetadataData.metadata || strategiesMetadataData.strategies || strategiesMetadataData;
                
                const rawFilterOptions = filterOptionsData.filters || filterOptionsData;
                filterOptions = {};
                Object.keys(rawFilterOptions).forEach(key => {
                    if (key !== 'version' && key !== 'lastUpdated') {
                        filterOptions[key] = rawFilterOptions[key];
                    }
                });
                
                accordionPresets = {};
                Object.keys(accordionPresetsData).forEach(key => {
                    if (key !== 'version' && key !== 'lastUpdated') {
                        accordionPresets[key] = accordionPresetsData[key];
                    }
                });

                // Load filter review status
                filterReviewStatus = filterReviewData.filters || {};

                allStrategies = strategiesContent.map(content => {
                    const metadata = strategiesMetadata.find(meta => meta.id === content.id);
                    return { ...content, ...metadata };
                });

                allStrategies = allStrategies.filter(strategy => 
                    strategy.title !== "Not Assigned" && 
                    strategy.overtitle !== "Not Assigned" &&
                    strategy.description !== "Not Assigned"
                );

                displayVersionInfo();
                return true;
            } catch (error) {
                console.error('Error loading data:', error);
                return false;
            }
        }

        // ========================================
        // FILTER REVIEW STATUS
        // ========================================
        function getFilterReviewStatus(filterKey, optionLabel) {
    if (!filterReviewStatus[filterKey]) return null;
    
    const optionStatus = filterReviewStatus[filterKey][optionLabel];
    if (!optionStatus) return null;
    
    // Get current IP right and build the dynamic key
    const currentIPRight = ipRightsFilter.value;
    if (!currentIPRight || currentIPRight === '') return null;
    
    const countKey = `review_count_${currentIPRight}`;
    const count = optionStatus[countKey] || 0;
    
    if (count === 0) {
        return { text: 'Not reviewed yet', class: 'not-reviewed', count: 0 };
    } else if (count <= 2) {
        return { text: `Reviewed ${count} time${count > 1 ? 's' : ''}`, class: 'few-reviews', count: count };
    } else {
        return { text: `Reviewed ${count} times`, class: 'many-reviews', count: count };
    }
}

        // ========================================
        // VALIDATION - turned off as it was previous version of tool
        // ========================================
        function validateRankDistribution() {
            return true; // <--- Add this line to bypass the warning logic
            const scores = filteredStrategies.map(s => s.calculatedScore);
            const uniqueScoresAbove1_2 = [...new Set(scores.filter(s => s > 1.2))];
            
            if (uniqueScoresAbove1_2.length > MAX_RANKS_ABOVE_1_2) {
                validationError.textContent = `‚ö†Ô∏è Maximum ${MAX_RANKS_ABOVE_1_2} unique score ranks allowed above 1.2. Currently: ${uniqueScoresAbove1_2.length} ranks (${uniqueScoresAbove1_2.sort((a,b) => b-a).join(', ')})`;
                validationError.style.display = 'block';
                return false;
            }
            
            validationError.style.display = 'none';
            return true;
        }

        // ========================================
        // SCORE ADJUSTMENT
        // ========================================
        function adjustScore(strategyId, adjustment) {
            const strategy = filteredStrategies.find(s => s.id === strategyId);
            if (!strategy) return;

            const newScore = Math.max(0, Math.min(3.0, strategy.calculatedScore + adjustment));
            const roundedScore = Math.round(newScore * 10) / 10;
            
            setScore(strategyId, roundedScore);
        }

        function setScore(strategyId, value) {
            const strategy = filteredStrategies.find(s => s.id === strategyId);
            if (!strategy) return;

            let newScore = parseFloat(value);
            if (isNaN(newScore)) newScore = originalScores[strategyId] || 1.0;
            
            newScore = Math.max(0, Math.min(3.0, newScore));
            const roundedScore = Math.round(newScore * 10) / 10;
            
            // Update the strategy score
            strategy.calculatedScore = roundedScore;

            // Store or update pending change
            const originalScore = originalScores[strategyId];
            if (roundedScore !== originalScore) {
                if (!pendingChanges[strategyId]) {
                    pendingChanges[strategyId] = {
                        oldScore: originalScore,
                        newScore: roundedScore,
                        reason: '',
                        status: 'pending'
                    };
                } else {
                    pendingChanges[strategyId].newScore = roundedScore;
                }
            } else {
                // Score returned to original - remove pending change
                delete pendingChanges[strategyId];
            }

            // Validate and re-render
            validateRankDistribution();
            renderStrategiesByRank();
                updateBulkButtonState(); 
        }

        function toggleNA(strategyId) {
            const strategy = filteredStrategies.find(s => s.id === strategyId);
            if (!strategy) return;

            if (strategy.calculatedScore === 0) {
                // Restore to original score
                const originalScore = originalScores[strategyId];
                setScore(strategyId, originalScore);
            } else {
                // Set to N/A
                setScore(strategyId, 0);
            }
        }

        function undoToOriginal(strategyId) {
            const strategy = filteredStrategies.find(s => s.id === strategyId);
            const originalScore = originalScores[strategyId];
            const currentScore = strategy ? strategy.calculatedScore : originalScore;
            
            // Log the undo if the score had been changed
            if (submittedChanges.has(strategyId) && currentScore !== originalScore) {
                logUndoAction(strategyId, currentScore, originalScore);
            }
            
            setScore(strategyId, originalScore);
            
            // Remove from pending and submitted
            delete pendingChanges[strategyId];
            submittedChanges.delete(strategyId);
            
            renderStrategiesByRank();
        }

        async function logUndoAction(strategyId, fromScore, toScore) {
            const strategy = filteredStrategies.find(s => s.id === strategyId);
            if (!strategy) return;

            const filterState = collectFilterState();
            
            const payload = {
                userName: currentUserName,
                userType: currentUserType,
                situationFilter: filterState.situationFilter,
                ipRightsFilter: filterState.ipRightsFilter,
                accordionFilters: filterState.accordionFilters,
                strategyId: strategy.id,
                strategyTitle: strategy.title,
                filterMode: filterState.filterMode,
                oldScore: String(fromScore),
                newScore: String(toScore),
                reason: 'UNDO TO ORIGINAL POSITION - User reverted their previous change',
                sessionId: TELEMETRY_CONFIG.sessionId,
                strategiesVersion: dataVersions.strategiesContent,
                metadataVersion: dataVersions.strategiesMetadata,
                filtersVersion: dataVersions.filterOptions,
                presetsVersion: dataVersions.accordionPresets,
                dataLoadTimestamp: dataVersions.loadTimestamp
            };
            
            try {
                await fetch(TELEMETRY_CONFIG.sheetURL, {
                    method: 'POST',
                    mode: 'no-cors',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(payload)
                });
            } catch (error) {
                console.error('Error logging undo:', error);
            }
        }

        // ========================================
        // TELEMETRY
        // ========================================
        function collectFilterState() {
            const accordionFiltersArray = activeFilters.map(filter => ({
                key: filter.key,
                option: filter.option.label
            }));

            // Determine if we are in single or multiple filter mode
    const filterMode = activeFilters.length > 1 ? 'Multiple' : 'Single';
            
            return {
                situationFilter: situationFilter.value || 'All Situations',
                ipRightsFilter: ipRightsFilter.value || 'All IP Rights',
                accordionFilters: JSON.stringify(accordionFiltersArray),
                filterMode: filterMode // Key returned here
            };
        }

        async function submitNoChangesNeeded(strategyId) {
            const strategy = filteredStrategies.find(s => s.id === strategyId);
            if (!strategy) return false;

            const filterState = collectFilterState();
            const originalScore = originalScores[strategyId];
            
            const payload = {
                userName: currentUserName,
                userType: currentUserType,
                situationFilter: filterState.situationFilter,
                ipRightsFilter: filterState.ipRightsFilter,
                accordionFilters: filterState.accordionFilters,
                strategyId: strategy.id,
                strategyTitle: strategy.title,
                filterMode: filterState.filterMode, // ADD THIS LINE
                oldScore: String(originalScore),
                newScore: String(originalScore),
                reason: 'NO CHANGES NEEDED - Reviewed and agreed with calculated score',
                sessionId: TELEMETRY_CONFIG.sessionId,
                strategiesVersion: dataVersions.strategiesContent,
                metadataVersion: dataVersions.strategiesMetadata,
                filtersVersion: dataVersions.filterOptions,
                presetsVersion: dataVersions.accordionPresets,
                dataLoadTimestamp: dataVersions.loadTimestamp
            };
            
            try {
                await fetch(TELEMETRY_CONFIG.sheetURL, {
                    method: 'POST',
                    mode: 'no-cors',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(payload)
                });
                
                submittedChanges.add(strategyId);
                        updateBulkButtonState(); // ADD THIS LINE
                renderStrategiesByRank();
                return true;
                
            } catch (error) {
                console.error('Error sending telemetry:', error);
                alert('Failed to submit review. Please try again.');
                return false;
            }
        }

function updateBulkButtonState() {
    const bulkBtn = document.getElementById('bulkNoChanges');
    const warningBanner = document.getElementById('pendingChangesWarning');
    
    if (!bulkBtn || !warningBanner) return;
    
    const hasAnyChanges = Object.keys(pendingChanges).length > 0 || submittedChanges.size > 0;
    const hasPendingWithoutReason = Object.values(pendingChanges).some(change => !change.reason.trim());
    
    // Show warning if there are pending changes without reasons
    if (hasPendingWithoutReason) {
        warningBanner.style.display = 'block';
    } else {
        warningBanner.style.display = 'none';
    }
    
    if (hasAnyChanges) {
        bulkBtn.disabled = true;
        bulkBtn.title = "Cannot mark as reviewed when changes are pending or submitted";
    } else {
        bulkBtn.disabled = false;
        bulkBtn.title = `Mark all ${filteredStrategies.length} visible strategies as correct`;
    }
}

async function bulkSubmitNoChanges() {
if (!confirm(`Confirm all ${filteredStrategies.length} visible options are correctly placed with no changes needed?`)) {
        return;
    }
    
    const bulkBtn = document.getElementById('bulkNoChanges');
    bulkBtn.disabled = true;
    bulkBtn.textContent = 'Submitting...';
    
    let successCount = 0;
    
    for (const strategy of filteredStrategies) {
        // Only submit if not already submitted
        if (!submittedChanges.has(strategy.id)) {
            const success = await submitNoChangesNeeded(strategy.id);
            if (success) successCount++;
        }
    }
    
    bulkBtn.textContent = '‚úì Mark All as Reviewed';
    updateBulkButtonState();
    
    alert(`Successfully confirmed ${successCount} strategies as correct.`);
}

        async function submitStrategyChange(strategyId) {
            const strategy = filteredStrategies.find(s => s.id === strategyId);
            const change = pendingChanges[strategyId];
            
            if (!strategy || !change || !change.reason.trim()) {
                alert('Please provide a reason for the change');
                return false;
            }

            const filterState = collectFilterState();
            
            const payload = {
                userName: currentUserName,
                userType: currentUserType,
                situationFilter: filterState.situationFilter,
                ipRightsFilter: filterState.ipRightsFilter,
                accordionFilters: filterState.accordionFilters,
                strategyId: strategy.id,
                strategyTitle: strategy.title,
                filterMode: filterState.filterMode,
                oldScore: String(change.oldScore),            //this captures zeros
                newScore: String(change.newScore),             //this captures zeros
                reason: change.reason,
                sessionId: TELEMETRY_CONFIG.sessionId,
                strategiesVersion: dataVersions.strategiesContent,
                metadataVersion: dataVersions.strategiesMetadata,
                filtersVersion: dataVersions.filterOptions,
                presetsVersion: dataVersions.accordionPresets,
                dataLoadTimestamp: dataVersions.loadTimestamp
            };
            
            try {
                await fetch(TELEMETRY_CONFIG.sheetURL, {
                    method: 'POST',
                    mode: 'no-cors',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(payload)
                });
                
                // Mark as submitted
                change.status = 'submitted';
                submittedChanges.add(strategyId);
                
                renderStrategiesByRank();
                 updateBulkButtonState(); 
                
                return true;
                
            } catch (error) {
                console.error('Error sending telemetry:', error);
                alert('Failed to submit change. Please try again.');
                return false;
            }
        }

        // ========================================
        // FILTER MANAGEMENT
        // ========================================
        function getAccordionLayout() {
            const selectedSituation = situationFilter.value;
            const selectedIPRight = ipRightsFilter.value;
            
            if (!selectedSituation && !selectedIPRight) {
                return accordionPresets.default || accordionPresets['default'];
            }
            
            const ipRightMap = {
                'Patent': 'patents',
                'Trade mark': 'trademarks',
                'Design': 'designs',
                'PBR': 'pbr',
                'Copyright': 'copyright',
                'Any dispute': 'any'
            };
            
            const situationMap = {
                'Enforcement': 'enforcement',
                'Accused': 'accused',
                'Proactive': 'proactive',
                'Disagree': 'disagree'
            };
            
            let presetKey = '';
            
            if (selectedIPRight && selectedSituation) {
                const ipKey = ipRightMap[selectedIPRight] || 'uncertain';
                const situationKey = situationMap[selectedSituation] || '';
                presetKey = `${ipKey}-${situationKey}`;
            } else if (selectedSituation) {
                const situationKey = situationMap[selectedSituation] || '';
                presetKey = `any-${situationKey}`;
            } else if (selectedIPRight) {
                return accordionPresets.default || accordionPresets['default'];
            }
            
            const layout = accordionPresets[presetKey];
            
            if (layout) {
                return layout;
            } else {
                return accordionPresets.default || accordionPresets['default'];
            }
        }

        function renderAccordions() {
            accordionContainer.innerHTML = '';
            
            const layout = getAccordionLayout();
            const accordions = layout.accordions || {};
            const topFilters = layout.topFilters || [];

            function isFilterActive(filterKey, optionIndex) {
                return activeFilters.some(f => f.key === filterKey && f.optionIndex === optionIndex);
            }

            function hasActiveFilterInGroup(filterKeys) {
                return filterKeys.some(key => 
                    activeFilters.some(f => f.key === key)
                );
            }

 // Render top filters OUTSIDE accordions
if (topFilters.length > 0) {
    const topFiltersContainer = document.createElement('div');
    topFiltersContainer.style.marginBottom = '24px';
    
    const topTitle = document.createElement('div');
    topTitle.style.fontWeight = '700';
    topTitle.style.fontSize = '16px';
    topTitle.style.color = '#374151';
    topTitle.style.marginBottom = '12px';
    topTitle.style.textTransform = 'uppercase';
    topTitle.style.letterSpacing = '0.5px';
    topTitle.textContent = 'Sort Options';
    topFiltersContainer.appendChild(topTitle);
    
    topFilters.forEach(filterKey => {
        const filterConfig = filterOptions[filterKey];
        if (!filterConfig) return;

        const group = document.createElement('div');
        group.style.marginBottom = '20px';

        const label = document.createElement('div');
        label.className = 'filter-label';
        label.textContent = filterConfig.label;
        group.appendChild(label);

        const radioGroup = document.createElement('div');
        radioGroup.className = 'radio-group';

        filterConfig.options.forEach((option, index) => {
            const radio = document.createElement('div');
            radio.className = 'radio-button';
            
            if (isFilterActive(filterKey, index)) {
                radio.classList.add('radio-selected');
            }
            
            const reviewStatus = getFilterReviewStatus(filterKey, option.label);
            let statusBadge = '';
            if (reviewStatus) {
                statusBadge = `<span class="review-status-badge ${reviewStatus.class}">${reviewStatus.text}</span>`;
            }
            
            radio.innerHTML = `${option.label}${statusBadge}`;
radio.onclick = () => {
    const newFilter = {
        key: filterKey,
        optionIndex: index,
        config: filterConfig,
        option: option
    };
    
    const existingIndex = activeFilters.findIndex(
        f => f.key === filterKey && f.optionIndex === index
    );
    
    if (existingIndex !== -1) {
        // Clicking the same filter again, deselect it
        activeFilters.splice(existingIndex, 1);
    } else {
        // Clear all filters and add only this one
        activeFilters = [newFilter];
    }
    
    clearSessionState();
    applyFilters();
    renderAccordions();
};
            radioGroup.appendChild(radio);
        });

        group.appendChild(radioGroup);
        topFiltersContainer.appendChild(group);
    });
    
    accordionContainer.appendChild(topFiltersContainer);
    
    // Add a divider before accordion sections
    const divider = document.createElement('div');
    divider.style.borderTop = '2px solid #e9ecef';
    divider.style.marginTop = '24px';
    divider.style.marginBottom = '24px';
    accordionContainer.appendChild(divider);
}

            Object.entries(accordions).forEach(([accordionTitle, filterKeys]) => {
                const accordionKey = accordionTitle.toLowerCase().replace(/\s+/g, '');
                const hasActiveFilter = hasActiveFilterInGroup(filterKeys);
                
                const header = document.createElement('div');
                header.className = 'accordion-header';
                const activeText = hasActiveFilter ? ' ‚úì' : '';
                
                header.innerHTML = `
                    <span style="display:inline-block; transition: transform 0.3s ease; transform: ${accordionState[accordionKey] ? 'rotate(90deg)' : 'rotate(0deg)'};">‚ñ∂</span>
                    ${accordionTitle}${activeText}
                `;
                
                header.onclick = () => {
                    accordionState[accordionKey] = !accordionState[accordionKey];
                    renderAccordions();
                };
                
                accordionContainer.appendChild(header);

                if (accordionState[accordionKey]) {
                    const content = document.createElement('div');
                    content.className = 'accordion-content';

                    filterKeys.forEach(filterKey => {
                        const filterConfig = filterOptions[filterKey];
                        if (!filterConfig) return;

                        const group = document.createElement('div');
                        group.style.marginBottom = '16px';

                        const label = document.createElement('div');
                        label.className = 'filter-label';
                        label.textContent = filterConfig.label;
                        group.appendChild(label);

                        const radioGroup = document.createElement('div');
                        radioGroup.className = 'radio-group';

                        filterConfig.options.forEach((option, index) => {
                            const radio = document.createElement('div');
                            radio.className = 'radio-button';
                            
                            if (isFilterActive(filterKey, index)) {
                                radio.classList.add('radio-selected');
                            }
                            
                            const reviewStatus = getFilterReviewStatus(filterKey, option.label);
                            let statusBadge = '';
                            if (reviewStatus) {
                                statusBadge = `<span class="review-status-badge ${reviewStatus.class}">${reviewStatus.text}</span>`;
                            }
                            
                            radio.innerHTML = `${option.label}${statusBadge}`;

radio.onclick = () => {
    const newFilter = {
        key: filterKey,
        optionIndex: index,
        config: filterConfig,
        option: option
    };
    
    const existingIndex = activeFilters.findIndex(
        f => f.key === filterKey && f.optionIndex === index
    );
    
    if (existingIndex !== -1) {
        // Clicking the same filter again, deselect it
        activeFilters.splice(existingIndex, 1);
    } else {
        // Clear all filters and add only this one
        activeFilters = [newFilter];
    }
    
    clearSessionState();
    applyFilters();
    renderAccordions();
};
                            
                            radioGroup.appendChild(radio);
                        });

                        group.appendChild(radioGroup);
                        content.appendChild(group);
                    });

                    accordionContainer.appendChild(content);
                }
            });
        }

        function clearSessionState() {
            pendingChanges = {};
            submittedChanges.clear();
            updateBulkButtonState(); 
        }

        function applyFilters() {
            const selectedSituation = situationFilter.value;
            const selectedIPRight = ipRightsFilter.value;

            // ADD THIS: If either primary filter is missing, show nothing
    if (!selectedSituation || !selectedIPRight) {
        filteredStrategies = [];
        updateActiveFilterDisplay();
        updateResultsCount();
        renderStrategiesByRank();
        updateBulkButtonState();
        return; 
    }

            filteredStrategies = allStrategies.filter(strategy => {
                if (selectedSituation && strategy.responseType) {
                    if (!strategy.responseType.includes(selectedSituation)) {
                        return false;
                    }
                }

                if (selectedIPRight && strategy.ipTypeTags) {
                    if (!strategy.ipTypeTags.includes(selectedIPRight) && 
                        !strategy.ipTypeTags.includes('Any dispute')) {
                        return false;
                    }
                }

                return true;
            });

            filteredStrategies = filteredStrategies.map(strategy => {
                let score = 1.0;
                
                activeFilters.forEach(filter => {
                    if (filterOptions[filter.key]) {
                        const option = filter.option;
                        if (option && option.scoringValues && strategy.id <= option.scoringValues.length) {
                            const filterScore = option.scoringValues[strategy.id - 1] || 1.0;
                            score *= filterScore;
                        }
                    }
                });
                
                const roundedScore = Math.round(score * 10) / 10;
                
                // Store original score
                originalScores[strategy.id] = roundedScore;
                
                return {
                    ...strategy,
                    calculatedScore: roundedScore
                };
            });

            updateActiveFilterDisplay();
            updateResultsCount();
            validateRankDistribution();
            renderStrategiesByRank();
                updateBulkButtonState();
        }

        function updateActiveFilterDisplay() {
            activeFilterPill.innerHTML = '';

            if (activeFilters.length > 0) {
                activeFilters.forEach((filter, index) => {
                    const config = filter.config;
                    const option = filter.option;
                    
                    let pillText = config.pillTemplate || `${config.label}: ${option.label}`;
                    pillText = pillText.replace('{optionLabel}', option.pillLabel || option.label);

                    const pill = document.createElement('div');
                    pill.className = 'active-filter-pill';
                    pill.style.marginRight = '8px';
                    pill.style.marginBottom = '8px';
                    pill.innerHTML = `
                        <span>${pillText}</span>
                        <button onclick="clearSpecificFilter(${index})">√ó</button>
                    `;
                    activeFilterPill.appendChild(pill);
                });
            }
        }

        function clearSpecificFilter(index) {
            activeFilters.splice(index, 1);
            clearSessionState();
            applyFilters();
            renderAccordions();
        }

        function clearAllFilters() {
            situationFilter.value = '';
            ipRightsFilter.value = '';
            activeFilters = [];
            accordionState = {};
            clearSessionState();
            applyFilters();
            renderAccordions();
        }

        function updateResultsCount() {
            resultsCount.textContent = `${filteredStrategies.length} strategies`;
        }

        // ========================================
        // RENDERING
        // ========================================
        function getRankLabel(score, isSingleFilter, percentile = null) {
            if (isSingleFilter) {
                if (score === 0) return { label: 'Not Applicable', subtitle: 'This strategy is fundamentally not applicable based on the filter applied', cssClass: 'not-applicable' };
                if (score < 0.9) return { label: 'Relevance is unlikely', subtitle: 'Based on the filter applied', cssClass: 'less-likely' };
                if (score < 1.0) return { label: 'Relevance is less likely', subtitle: 'Based on the filter applied', cssClass: 'less-likely' };
                if (score === 1.0) return { label: 'Relevance is uneffected', subtitle: 'Irrelevant to filter applied', cssClass: 'no-effect' };
                if (score > 1.2) return { label: 'Relevance is highly likely', subtitle: 'Based on the filter applied', cssClass: 'more-likely' };
                if (score > 1.0) return { label: 'Relevance is more likely', subtitle: 'Based on the filter applied', cssClass: 'more-likely' };

            } else {
                // Multiple filters - use percentile-based bands
                if (score === 0) return { label: 'Not Applicable', subtitle: 'Based on filters applied', cssClass: 'not-applicable' };
                
                // Use percentile to determine band
                if (percentile !== null) {
                    if (percentile <= 0.20) return { label: 'Relevance: Highly Likely', subtitle: 'Top 20% based on filters applied', cssClass: 'more-likely' };
                    if (percentile <= 0.40) return { label: 'Relevance: Likely', subtitle: 'Top 40% based on filters applied', cssClass: 'more-likely' };
                    if (percentile <= 0.60) return { label: 'Relevance: Possible', subtitle: 'Middle 20% based on filters applied', cssClass: 'no-effect' };
                    if (percentile <= 0.80) return { label: 'Relevance: Unlikely', subtitle: 'Bottom 40% based on filters applied', cssClass: 'less-likely' };
                    return { label: 'Relevance: Unlikely', subtitle: 'Bottom 20% based on filters applied', cssClass: 'less-likely' };
                }
                
                // Fallback if percentile not provided (shouldn't happen)
                return { label: 'Relevance: Unknown', subtitle: 'Based on filters applied', cssClass: 'no-effect' };
            }
        }

        function renderStrategiesByRank() {
            if (filteredStrategies.length === 0) {
                strategiesContainer.innerHTML = `
                    <div class="no-results">
                        <h3>No strategies found</h3>
                        <p>Try adjusting your filters</p>
                    </div>
                `;
                return;
            }

// Check if any filters are selected from the sidebar
if (activeFilters.length === 0) {
    strategiesContainer.innerHTML = `
        <div class="no-results">
            <h3>No filter selected</h3>
            <p>Please select a filter from the sidebar to view strategies</p>
        </div>
    `;
    return;
}

            const isSingleFilter = activeFilters.length === 1;

            // For multiple filters, calculate percentiles
// For multiple filters, calculate percentiles
let percentileMap = {};
if (!isSingleFilter) {
    // Separate non-zero scores and sort them
    const nonZeroStrategies = filteredStrategies.filter(s => s.calculatedScore !== 0);
    
    // Sort strategies by score (descending)
    const sortedStrategies = [...nonZeroStrategies].sort((a, b) => b.calculatedScore - a.calculatedScore);
    
    // Calculate percentile for each strategy based on their position
    sortedStrategies.forEach((strategy, index) => {
        const percentile = (index + 1) / sortedStrategies.length;
        percentileMap[strategy.id] = percentile;
    });
}

  strategiesContainer.innerHTML = '';

if (isSingleFilter) {
    // SINGLE FILTER: Group by exact score
    const scoreGroups = {};
    filteredStrategies.forEach(strategy => {
        const score = strategy.calculatedScore;
        if (!scoreGroups[score]) {
            scoreGroups[score] = [];
        }
        scoreGroups[score].push(strategy);
    });

    const sortedScores = Object.keys(scoreGroups).map(s => parseFloat(s)).sort((a, b) => b - a);

    sortedScores.forEach(score => {
        const strategies = scoreGroups[score];
        const rankInfo = getRankLabel(score, true, null);
                
                const rankGroup = document.createElement('div');
                rankGroup.className = 'rank-group';

                const rankHeader = document.createElement('div');
                rankHeader.className = 'rank-header';
                
                rankHeader.innerHTML = `
                    <div class="rank-title">
                        <span class="rank-badge ${rankInfo.cssClass}">${rankInfo.label}</span>
                        <span style="font-size: 13px; color: #6b7280;">${rankInfo.subtitle}</span>
                    </div>
                    <span class="rank-count">${strategies.length} strateg${strategies.length === 1 ? 'y' : 'ies'} ‚Ä¢ Score: ${score}</span>
                `;
                rankGroup.appendChild(rankHeader);

                const strategiesRow = document.createElement('div');
                strategiesRow.className = 'strategies-row';

strategies.forEach(strategy => {
    const card = createStrategyCard(strategy, true); // Pass true for isSingleFilter
    strategiesRow.appendChild(card);
});

                rankGroup.appendChild(strategiesRow);
                strategiesContainer.appendChild(rankGroup);
            });
     } else {
    // MULTIPLE FILTERS: Group by percentile band
    const bands = {
        'top20': { strategies: [], label: 'Relevance: Highly Likely', subtitle: 'Top 20% based on filters applied', cssClass: 'more-likely' },
        'top40': { strategies: [], label: 'Relevance: Likely', subtitle: 'Top 40% based on filters applied', cssClass: 'more-likely' },
        'mid60': { strategies: [], label: 'Relevance: Possible', subtitle: 'Middle 20% based on filters applied', cssClass: 'no-effect' },
        'bot80': { strategies: [], label: 'Relevance: Unlikely', subtitle: 'Bottom 40% based on filters applied', cssClass: 'less-likely' },
        'bot100': { strategies: [], label: 'Relevance: Unlikely', subtitle: 'Bottom 20% based on filters applied', cssClass: 'less-likely' },
        'na': { strategies: [], label: 'Not Applicable', subtitle: 'Based on filters applied', cssClass: 'not-applicable' }
    };

    // Assign each strategy to a band
    filteredStrategies.forEach(strategy => {
        if (strategy.calculatedScore === 0) {
            bands['na'].strategies.push(strategy);
        } else {
            const percentile = percentileMap[strategy.id];
            if (percentile <= 0.20) {
                bands['top20'].strategies.push(strategy);
            } else if (percentile <= 0.40) {
                bands['top40'].strategies.push(strategy);
            } else if (percentile <= 0.60) {
                bands['mid60'].strategies.push(strategy);
            } else if (percentile <= 0.80) {
                bands['bot80'].strategies.push(strategy);
            } else {
                bands['bot100'].strategies.push(strategy);
            }
        }
    });

    // Render each band that has strategies
    const bandOrder = ['top20', 'top40', 'mid60', 'bot80', 'bot100', 'na'];
    bandOrder.forEach(bandKey => {
        const band = bands[bandKey];
        if (band.strategies.length === 0) return;

        // Calculate score range for this band
        const scores = band.strategies.map(s => s.calculatedScore);
        const minScore = Math.min(...scores).toFixed(2);
        const maxScore = Math.max(...scores).toFixed(2);
        const scoreRange = minScore === maxScore ? minScore : `${minScore} - ${maxScore}`;

        const rankGroup = document.createElement('div');
        rankGroup.className = 'rank-group';

        const rankHeader = document.createElement('div');
        rankHeader.className = 'rank-header';
        
        rankHeader.innerHTML = `
            <div class="rank-title">
                <span class="rank-badge ${band.cssClass}">${band.label}</span>
                <span style="font-size: 13px; color: #6b7280;">${band.subtitle}</span>
            </div>
            <span class="rank-count">${band.strategies.length} strateg${band.strategies.length === 1 ? 'y' : 'ies'} ‚Ä¢ Score range: ${scoreRange}</span>
        `;
        rankGroup.appendChild(rankHeader);

        const strategiesRow = document.createElement('div');
        strategiesRow.className = 'strategies-row';

        band.strategies.forEach(strategy => {
            const card = createStrategyCard(strategy, false); // Pass false for isSingleFilter
            strategiesRow.appendChild(card);
        });

        rankGroup.appendChild(strategiesRow);
        strategiesContainer.appendChild(rankGroup);
    });
}
        }

         function createStrategyCard(strategy, isSingleFilter = true) {
    const card = document.createElement('div');
    card.className = 'strategy-card';

    const isNA = strategy.calculatedScore === 0;
    const pending = pendingChanges[strategy.id];
    const isSubmitted = submittedChanges.has(strategy.id);
    const hasChanged = originalScores[strategy.id] !== strategy.calculatedScore;

    // Display score with appropriate decimal places
    const displayScore = isSingleFilter ? strategy.calculatedScore : strategy.calculatedScore.toFixed(2);

    let statusBadge = '';
    if (isSubmitted) {
        statusBadge = '<div class="status-badge submitted">‚úì Submitted</div>';
    } else if (hasChanged && pending && !pending.reason.trim()) {
        statusBadge = '<div class="status-badge pending">‚è≥ Reason Required</div>';
    }

    // Use contentCardUrl from JSON data, fallback to placeholder if not present
    const strategyLink = strategy.contentCardUrl || `https://ipnavigator.com.au/strategy/${strategy.id}`;

    card.innerHTML = `
        ${statusBadge}
        <div class="card-header">
            ${strategy.overtitle ? `<div class="card-overtitle">${strategy.overtitle}</div>` : ''}
            <div class="card-title">${strategy.title}</div>
            <div class="card-description">${strategy.description}</div>
            <a href="${strategyLink}" target="_blank" class="card-link">Review content card ‚Üí</a>
        </div>
        <div class="card-controls">
            <div class="score-control">
                <input type="number" 
                       class="score-input" 
                       value="${isNA ? '0' : displayScore}" 
                       min="0" 
                       max="3" 
                       step="0.1" 
                       onchange="setScore(${strategy.id}, this.value)"
                       title="Enter score (0-3.0)">
                        <div class="score-buttons">
                            <button class="score-btn" onclick="adjustScore(${strategy.id}, 0.1)" title="Increase score" ${isNA ? 'disabled' : ''}>‚ñ≤</button>
                            <button class="score-btn" onclick="adjustScore(${strategy.id}, -0.1)" title="Decrease score" ${isNA ? 'disabled' : ''}>‚ñº</button>
                            <button class="na-btn ${isNA ? 'active' : ''}" onclick="toggleNA(${strategy.id})" title="Mark as Not Applicable">N/A</button>
                        </div>
                    </div>
                    ${hasChanged && !isSubmitted ? `
                        <textarea 
                            class="reason-input" 
                            placeholder="Why are you changing this score? (required)"
                            oninput="updateReason(${strategy.id}, this.value)"
                        >${pending ? pending.reason : ''}</textarea>
                        <button class="submit-reason-btn" 
                                onclick="submitStrategyChange(${strategy.id})"
                                ${!pending || !pending.reason.trim() ? 'disabled' : ''}>
                            Submit Change
                        </button>
                        <button class="undo-btn" onclick="undoToOriginal(${strategy.id})">
                            Undo to Original Position
                        </button>
                    ` : ''}
                    ${isSubmitted ? `
                        <button class="undo-btn" onclick="undoToOriginal(${strategy.id})">
                            Undo, move to original position
                        </button>
                    ` : ''}

                </div>
            `;

            return card;
        }

function updateReason(strategyId, reason) {
    if (pendingChanges[strategyId]) {
        pendingChanges[strategyId].reason = reason;
        
        // Just update the submit button state without re-rendering everything
        const submitBtn = document.querySelector(`button[onclick="submitStrategyChange(${strategyId})"]`);
        if (submitBtn) {
            submitBtn.disabled = !reason.trim();
        }
    }
}

        // ========================================
        // EVENT LISTENERS
        // ========================================
        function setupEventListeners() {
            situationFilter.addEventListener('change', () => {
                clearSessionState();
                applyFilters();
                renderAccordions();
            });
            ipRightsFilter.addEventListener('change', () => {
                clearSessionState();
                applyFilters();
                renderAccordions();
            });
            clearFilters.addEventListener('click', clearAllFilters);
            document.getElementById('bulkNoChanges').addEventListener('click', bulkSubmitNoChanges);
        }

        // Make functions globally available
        window.adjustScore = adjustScore;
        window.setScore = setScore;
        window.toggleNA = toggleNA;
        window.clearSpecificFilter = clearSpecificFilter;
        window.checkPassword = checkPassword;
        window.undoToOriginal = undoToOriginal;
        window.submitStrategyChange = submitStrategyChange;
        window.submitNoChangesNeeded = submitNoChangesNeeded;
        window.updateReason = updateReason;
        window.bulkSubmitNoChanges = bulkSubmitNoChanges;
        window.updateBulkButtonState = updateBulkButtonState;

        // ========================================
        // INITIALIZATION
        // ========================================
        async function init() {
            const dataLoaded = await loadData();
            
            if (!dataLoaded) {
                strategiesContainer.innerHTML = `
                    <div class="no-results">
                        <h3>Failed to load data</h3>
                        <p>Please check that all data is available</p>
                    </div>
                `;
                return;
            }

            setupEventListeners();
            renderAccordions();
            applyFilters();
                updateBulkButtonState(); 
        }

        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
